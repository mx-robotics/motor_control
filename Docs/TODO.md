

##### New motor, New board:

* The new motor performs horribly. The reason might be its lower Kv rating. 

  Things to do:

  * Check the current draw compared to the old motors. If the new ones have a lower Kv, they should draw also less current.
  
    This seems to be correct. The new motors draw 0.5 A at 14.8 V compared to old motor's 0.9 A. One of the old motors (cable dependent one) draws 1.4 Amps and its torque is crazy. This is very weird since the old motors are identical. I wonder which one is malfunctioning. The other one is also very weird since it draws 0.9 Amps for each phase except 1. All Those tests are done vith 6-step BLDC test. **Next step:** This is good! You know the motor phases are identical between old motors and also between new motors, put them the BLDC test and simultaneously measure the angle to deduce an offset, i dont know how 6 step commutation corresponds to SVPWM domain but still we can use this to see an offset difference between different motors. **OLD MOTORS -> WVU, NEW MOTORS UVW, plugging opposite**
  
  
  
  * Understand the concept of Kv better! The idea is more like the torque density/efficiency, rather than torque produced. You draw less Amps but produce more torque per amp (higher Kt). In the end, the torque produced is the same. It comes down to:
    * you want to operate with higher voltage but draw less current. It is safer and more battery lifetime friendly but you need a higher voltage source.
    * You want to operate with lower voltage but draw more current. You can use lower voltage batteries but the life time is shorter since you draw more current. (Battery voltage and capacity are very different things -> Volts vs amperes per hour)

  * Test the old motors with the old setup and:
    * determine if both motors are working 
    
      Both of them seem to work, but one (marked) is very unstable and its operation really depends on the cables. It also draws more current compared to its counter-part during a BLDC-like test.
  
    * if a 120° shift with the phases still functions
    
      It does function with +120° but not with a -120° shift. 
    
    * if not, check if the rotor flux is order dependent. **Important**
    
      I **haven't checked it by going through the hassle of check each phase but it is clear that rotor angle offset is order dependent.** It might even be motor dependent and its quite possible that there is no universal formula to calculate it.
    
  * When/if you can get the same functionality with the old motor, start working with the new ones. As explained in the KV section, the new ones would be more suitable for higher voltages. For example if we try to run the old motor with 7 volts, we will most probably be disappointed. The new motors might just need a lot more to function properly.

##### Redundant optimizations

* do proper benchmarking of the code.

  The code is fast enough. its takes around 13 microseconds with 120000000 MHZ over-clocking for 1 motor to do its thing. This can be halved by switching to fixed point math instead of floating math since they take much of the time.

* ~~Figure out how the hell you can use constexpr sin cos etc although it is clearly not supported on any cpp compiler~~

  Non-conform compiler extensions: Gcc marks its own functions as constexpr. Clang wont compile it. If you want it to be portable to other compiler suits, dont use this.

* ~~Check the arm DSP library~~ -> [here](https://arm-software.github.io/CMSIS_5/DSP/html/index.html) 

  The dsp library is designed to be used on arrays rather than single floats. The performance is **worse ** compared to software float multiplication on just 2 floats. A simple fixed point math library would do better. The dsp library has still some good functionality like a PID implementation, motor control related transforms etc.

* ~~tryout a non constexpr LUT version~~.

  Constexpr and consts, both of them go to Flash in any case. A dynamic look-up table can be put on RAM but the overhead of access is very little.

* ~~Implement the lookup table generator on linux to see how it looks like. The point is to be able to compare the scaling to see if it is actually right.~~

  Done, test written, also the LUTs generated by the microcontroller itself has been copied and tested against the Linux implementation. Everything looks fine from that side.

* ~~check for a constexpr sin library and try it.~~

  gcc defaults are constexpr.

* check for an easy to use fixed point math library. cpp 

* ~~Check for the static overhead, you might wanna change the whole implementation~~

  ~~The statics do have a slight overhead and i will change the implementation but not due to speed concerns rather due to stack usage and redundancy of a static implementation~~.

  The statics are fine, and they are fine from a design perspective. 

* ~~Instead of doing stuff on the the interrupt, do in in the while loop.~~  This works just fine.

* An idea is to trigger the code body with the very first interrupt and close the interrupt till the end of the code body. The best way is stil to be able to do it when the whole cycle starts(load value) instead of doing it on the match value.  Check how many times and interrupt comes, if its up count only, you are golden. Actually you also know which PWM channel is being used based on the angle you have fetched (more like you know it based on the LUT index).

* Try attach interruptVector

  ##### Control stuff

* Feedforward PID, implement what George suggested. The main idea is, have a feed forward model - you have this sorta - this much speed_scaler this much rps. The PID should come on top of this. so in an ideal case PID output should be 0.  if you have a disturbance the feedforward term would not change but there would be an error which the PID will try to minimize. How aggressive this will be depends on the tuning. When the set point changes, the feed forward  terminstantly changes as well - goes higher or lower - and there will be an error which will be modified by PID gains and contribute further to FF(FEED FORWARD). for example it will increase or decrease the command further which will cause more agressive set point tracking. Again, the agression is defined by the PID gains. As the error goes to 0, the PID conributuion goes to zero as well.

  

* Write a wrapper class for the embedded stuff

* make the new motor spin, first try the blind spin - called primitive spin

* there is weird jump at the middle when you are doing scaling -> 1494 - measuredAngle, take care of it.

  

* Check the HW desing app note from infineon and ask SE about the symetric decoupling

